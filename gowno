import streamlit as st
import pandas as pd
import os
import altair as alt
from datetime import datetime, timedelta, date, time
from dateutil.relativedelta import relativedelta
from streamlit_calendar import calendar

# --- KONFIGURACJA STRONY ---
st.set_page_config(page_title="Mened≈ºer Korepetycji", layout="wide", page_icon="üìö")

# --- PLIKI DANYCH ---
FILE_DB = 'uczniowie.csv'
FILE_SETTLEMENTS = 'rozliczenia.csv'
FILE_CANCELLATIONS = 'odwolane.csv'
FILE_EXTRA = 'dodatkowe.csv'

# Definicja kolumn
COLUMNS = [
    'ID', 'Imie', 'Nazwisko', 'H_w_tygodniu', 'Stawka', 
    'Dojazd',
    'Nieobecnosci', 'Odrabiania', 'Do_odrobienia_umowione', 'Do_odrobienia_nieumowione',
    'Szkola', 'Klasa', 'Poziom', 'Nr_tel', 
    'Data_rozp', 'Data_zak', 'Dzien_tyg', 'Godzina', 'Adres',
    'Tryb_platnosci'
]
COLUMNS_SETTLEMENTS = ['Uczen_ID', 'Okres', 'Kwota_Wymagana', 'Wplacono']
COLUMNS_CANCELLATIONS = ['Uczen_ID', 'Data', 'Powod']
# Dodajemy kolumnƒô 'Status' do ≈õledzenia czy odrabianie zosta≈Ço ju≈º "zaliczone" (minƒÖ≈Ç termin)
COLUMNS_EXTRA = ['Uczen_ID', 'Data', 'Godzina', 'Stawka', 'Typ', 'Czas', 'Status']

# Mapowanie dni tygodnia
DNI_MAPA = {
    "Poniedzia≈Çek": 0, "Wtorek": 1, "≈öroda": 2, "Czwartek": 3, 
    "PiƒÖtek": 4, "Sobota": 5, "Niedziela": 6
}
MIESIACE_PL = {
    1: 'Stycze≈Ñ', 2: 'Luty', 3: 'Marzec', 4: 'Kwiecie≈Ñ', 5: 'Maj', 6: 'Czerwiec',
    7: 'Lipiec', 8: 'Sierpie≈Ñ', 9: 'Wrzesie≈Ñ', 10: 'Pa≈∫dziernik', 11: 'Listopad', 12: 'Grudzie≈Ñ'
}

# --- FUNKCJE ≈ÅADOWANIA DANYCH ---
def load_data():
    if not os.path.exists(FILE_DB): return pd.DataFrame(columns=COLUMNS)
    try:
        df = pd.read_csv(FILE_DB)
        if 'Tryb_platnosci' not in df.columns: df['Tryb_platnosci'] = 'Co zajƒôcia'
        
        # Obs≈Çuga typ√≥w liczbowych
        df['Stawka'] = pd.to_numeric(df['Stawka'], errors='coerce').fillna(0)
        if 'Dojazd' not in df.columns: df['Dojazd'] = 0.0
        df['Dojazd'] = pd.to_numeric(df['Dojazd'], errors='coerce').fillna(0)
        df['H_w_tygodniu'] = df['H_w_tygodniu'].astype(str).replace('nan', '1.0')
        
        # Liczniki numeryczne (float dla godzin)
        cols_int = ['Odrabiania', 'Nieobecnosci', 'Do_odrobienia_umowione', 'Do_odrobienia_nieumowione']
        for c in cols_int:
            df[c] = pd.to_numeric(df[c], errors='coerce').fillna(0.0)
            
        text_cols = ['Szkola', 'Klasa', 'Poziom', 'Nr_tel', 'Adres', 'Dzien_tyg', 'Godzina']
        for col in text_cols:
            if col in df.columns:
                df[col] = df[col].fillna("-")
        return df
    except: return pd.DataFrame(columns=COLUMNS)

def save_data(df): df.to_csv(FILE_DB, index=False)

def load_settlements():
    if not os.path.exists(FILE_SETTLEMENTS): return pd.DataFrame(columns=COLUMNS_SETTLEMENTS)
    try:
        df = pd.read_csv(FILE_SETTLEMENTS)
        if 'Miesiac' in df.columns: df.rename(columns={'Miesiac': 'Okres'}, inplace=True)
        if 'Zaplacono' in df.columns and 'Wplacono' not in df.columns:
            if 'Kwota' in df.columns: df.rename(columns={'Kwota': 'Kwota_Wymagana'}, inplace=True)
            df['Wplacono'] = 0.0
            df.loc[df['Zaplacono'] == True, 'Wplacono'] = df['Kwota_Wymagana']
            df.drop(columns=['Zaplacono'], inplace=True, errors='ignore')
        for col in COLUMNS_SETTLEMENTS:
            if col not in df.columns: df[col] = 0.0 if col in ['Kwota_Wymagana', 'Wplacono'] else ""
        return df
    except: return pd.DataFrame(columns=COLUMNS_SETTLEMENTS)

def save_settlements(df): df.to_csv(FILE_SETTLEMENTS, index=False)

def load_cancellations():
    if not os.path.exists(FILE_CANCELLATIONS): return pd.DataFrame(columns=COLUMNS_CANCELLATIONS)
    try:
        df = pd.read_csv(FILE_CANCELLATIONS)
        if 'Powod' not in df.columns: df['Powod'] = 'Nieznany'
        return df
    except: return pd.DataFrame(columns=COLUMNS_CANCELLATIONS)

def save_cancellations(df): df.to_csv(FILE_CANCELLATIONS, index=False)

def load_extra():
    if not os.path.exists(FILE_EXTRA): return pd.DataFrame(columns=COLUMNS_EXTRA)
    try:
        df = pd.read_csv(FILE_EXTRA)
        if 'Typ' not in df.columns: df['Typ'] = 'Dodatkowa'
        if 'Czas' not in df.columns: df['Czas'] = 1.0 
        if 'Status' not in df.columns: df['Status'] = 'Zaplanowana' # Domy≈õlny status dla starych wpis√≥w
        return df
    except: return pd.DataFrame(columns=COLUMNS_EXTRA)

def save_extra(df): df.to_csv(FILE_EXTRA, index=False)

# --- LOGIKA AUTOMATYCZNEJ AKTUALIZACJI LICZNIK√ìW ---
def process_past_makeups(df_students, df_extra):
    """
    Sprawdza czy minƒô≈Çy terminy odrabiania. 
    Je≈õli tak (data < dzis): zmniejsza licznik 'Do_odrobienia_umowione' i oznacza lekcjƒô jako 'Zrealizowana'.
    """
    today = date.today()
    changes = False
    
    for idx, row in df_extra.iterrows():
        # InteresujƒÖ nas tylko lekcje typu Odrabianie
        if row.get('Typ') == 'Odrabianie':
            try:
                l_date = pd.to_datetime(row['Data']).date()
                status = row.get('Status', 'Zaplanowana')
                
                # Je≈õli termin minƒÖ≈Ç (jest wczoraj lub dawniej) i nie jest jeszcze rozliczony
                if l_date < today and status != 'Zrealizowana':
                    # Znajd≈∫ ucznia
                    s_idx = df_students.index[df_students['ID'] == row['Uczen_ID']].tolist()
                    if s_idx:
                        s_idx = s_idx[0]
                        # Zmniejsz licznik o czas trwania tej konkretnej lekcji
                        curr_val = df_students.at[s_idx, 'Do_odrobienia_umowione']
                        duration = float(row.get('Czas', 1.0))
                        
                        if curr_val > 0:
                            # Zabezpieczenie przed ujemnymi, choƒá teoretycznie nie powinno wystƒÖpiƒá
                            df_students.at[s_idx, 'Do_odrobienia_umowione'] = max(0.0, curr_val - duration)
                            
                        # Oznacz lekcjƒô jako 'Zrealizowana' w bazie dodatkowych
                        df_extra.at[idx, 'Status'] = 'Zrealizowana'
                        changes = True
            except Exception as e:
                pass # Ignorujemy b≈Çƒôdy parsowania daty itp.
                
    if changes:
        save_data(df_students)
        save_extra(df_extra)
        return True
    return False

# --- LOGIKA PARSOWANIA WIELU TERMIN√ìW ---
def parse_student_terms(row):
    days = str(row['Dzien_tyg']).split(';')
    times = str(row['Godzina']).split(';')
    durations = str(row['H_w_tygodniu']).split(';')
    
    terms = []
    for i, day in enumerate(days):
        day = day.strip()
        if not day or day == '-': continue
        time_str = times[i].strip() if i < len(times) else (times[-1].strip() if times else "00:00")
        try:
            dur_str = durations[i].strip() if i < len(durations) else (durations[-1].strip() if durations else "1.0")
            dur_val = float(dur_str)
        except: dur_val = 1.0
        terms.append({'day_name': day, 'time_str': time_str, 'duration': dur_val})
    return terms

# --- G≈Å√ìWNA LOGIKA KALENDARZA I FINANS√ìW ---

def get_lessons_in_period(df_students, start_date, end_date):
    lessons = []
    df_cancel = load_cancellations()
    df_extra = load_extra()
    
    cancelled_set = set()
    if not df_cancel.empty:
        for _, row in df_cancel.iterrows():
            cancelled_set.add((row['Uczen_ID'], str(row['Data'])))

    # 1. Generowanie lekcji sta≈Çych
    current_day = start_date
    while current_day <= end_date:
        weekday_num = current_day.weekday()
        for _, row in df_students.iterrows():
            terms = parse_student_terms(row)
            for term in terms:
                if term['day_name'] in DNI_MAPA and DNI_MAPA[term['day_name']] == weekday_num:
                    try:
                        c_start = pd.to_datetime(row['Data_rozp']).date()
                        c_end = pd.to_datetime(row['Data_zak']).date()
                        if c_start <= current_day <= c_end:
                            if (row['ID'], str(current_day)) not in cancelled_set:
                                full_rate = (row['Stawka'] * term['duration']) + row.get('Dojazd', 0)
                                lessons.append({
                                    'Data': current_day,
                                    'Uczen_ID': row['ID'],
                                    'Stawka': full_rate, 
                                    'Godzina': term['time_str'],
                                    'Imie': row['Imie'],
                                    'Nazwisko': row['Nazwisko'],
                                    'Typ': 'Sta≈Ça',
                                    'Czas': term['duration']
                                })
                    except: pass
        current_day += timedelta(days=1)

    # 2. Dodatkowe
    if not df_extra.empty:
        for _, row in df_extra.iterrows():
            try:
                l_date = pd.to_datetime(row['Data']).date()
                if start_date <= l_date <= end_date:
                    student = df_students[df_students['ID'] == row['Uczen_ID']]
                    if not student.empty:
                        s_row = student.iloc[0]
                        duration = float(row.get('Czas', 1.0))
                        
                        lessons.append({
                            'Data': l_date,
                            'Uczen_ID': row['Uczen_ID'],
                            'Stawka': row['Stawka'],
                            'Godzina': row['Godzina'],
                            'Imie': s_row['Imie'],
                            'Nazwisko': s_row['Nazwisko'],
                            'Typ': row.get('Typ', 'Dodatkowa'),
                            'Czas': duration
                        })
            except: pass
            
    return lessons

def calculate_income(df_students, start_date, end_date):
    lessons = get_lessons_in_period(df_students, start_date, end_date)
    return sum(l['Stawka'] for l in lessons)

def calculate_monthly_breakdown(df_students, student_id, target_month_date):
    breakdown = []
    total_amount = 0.0
    student_row = df_students[df_students['ID'] == student_id].iloc[0]
    terms = parse_student_terms(student_row)
    tryb = student_row.get('Tryb_platnosci', 'Co zajƒôcia')
    
    y, m = target_month_date.year, target_month_date.month
    curr_start = date(y, m, 1)
    curr_end = curr_start + relativedelta(months=1) - timedelta(days=1)
    
    c_start = pd.to_datetime(student_row['Data_rozp']).date()
    c_end = pd.to_datetime(student_row['Data_zak']).date()
    
    # 1. PLAN BAZOWY NA TEN MIESIƒÑC
    lessons_count = 0
    base_cost_accumulated = 0.0
    day_ptr = curr_start
    while day_ptr <= curr_end:
        for term in terms:
            target_day_num = DNI_MAPA.get(term['day_name'])
            if day_ptr.weekday() == target_day_num:
                if c_start <= day_ptr <= c_end:
                    lessons_count += 1
                    cost = (student_row['Stawka'] * term['duration']) + student_row.get('Dojazd', 0)
                    base_cost_accumulated += cost
        day_ptr += timedelta(days=1)
            
    total_amount += base_cost_accumulated
    label_base = f"Abonament: {MIESIACE_PL[m]}" if tryb == 'Miesiƒôcznie' else f"Planowe zajƒôcia: {MIESIACE_PL[m]}"
    
    breakdown.append({
        "Opis": f"{label_base} (Liczba: {lessons_count})",
        "Kwota": base_cost_accumulated,
        "Typ": "Baza"
    })
    
    # 2. ZAKRES DLA KOREKT
    # ZMIANA: Wszystkie korekty (dodatkowe, odwo≈Çania) sƒÖ teraz widoczne w TYM SAMYM miesiƒÖcu
    query_start = curr_start
    query_end = curr_end
    
    # A) Dodatkowe i Odrabianie
    df_extra = load_extra()
    if not df_extra.empty:
        extras = df_extra[
            (df_extra['Uczen_ID'] == student_id) & 
            (pd.to_datetime(df_extra['Data']).dt.date >= query_start) & 
            (pd.to_datetime(df_extra['Data']).dt.date <= query_end)
        ]
        for _, row in extras.iterrows():
            typ = row.get('Typ', 'Dodatkowa')
            dur = row.get('Czas', 1.0)
            
            # Dwie zmienne:
            # 1. kwota_do_sumy - wp≈Çywa na sumƒô "Abonamentu" w rejestrze (dla logiki zwrotu total_amount)
            # 2. kwota_do_wyswietlenia - pokazuje realny koszt w tabelce szczeg√≥≈Ç√≥w
            
            kwota_do_sumy = 0.0
            kwota_do_wyswietlenia = 0.0
            opis_typ = ""
            
            if typ == 'Dodatkowa':
                kwota_do_wyswietlenia = row['Stawka']
                opis_typ = f"P≈Çatna ekstra ({dur}h)"
                
                # ZMIANA: W trybie miesiƒôcznym nie dodajemy do sumy g≈Ç√≥wnego rachunku,
                # bo jest to osobny wiersz w rejestrze. Ale w szczeg√≥≈Çach pokazujemy kwotƒô.
                if tryb == 'Miesiƒôcznie':
                    kwota_do_sumy = 0.0
                    opis_typ += " (Osobna pozycja w rejestrze)"
                else:
                    # W trybie co zajƒôcia doliczamy do sumy miesiƒÖca (dla informacji ile razem)
                    kwota_do_sumy = row['Stawka']
                
            elif typ == 'Odrabianie' or typ == 'Prze≈Ço≈ºona':
                if tryb == 'Co zajƒôcia':
                    kwota_do_sumy = row['Stawka']
                    kwota_do_wyswietlenia = row['Stawka']
                    opis_typ = f"Odrabianie ({dur}h)"
                else:
                    # W miesiƒôcznym odrabianie za 0
                    kwota_do_sumy = 0.0
                    kwota_do_wyswietlenia = 0.0
                    opis_typ = f"Odrabianie - bez dop≈Çaty ({dur}h)"
            
            total_amount += kwota_do_sumy
            breakdown.append({
                "Opis": f"{typ}: {row['Data']}",
                "Kwota": kwota_do_wyswietlenia, # Tu pokazujemy faktyczny koszt dla informacji
                "Typ": opis_typ
            })
            
    # B) Odwo≈Çane lekcje
    df_cancel = load_cancellations()
    if not df_cancel.empty:
        cancels = df_cancel[
            (df_cancel['Uczen_ID'] == student_id) & 
            (pd.to_datetime(df_cancel['Data']).dt.date >= query_start) & 
            (pd.to_datetime(df_cancel['Data']).dt.date <= query_end)
        ]
        for _, row in cancels.iterrows():
            powod = row.get('Powod', 'Nieznany')
            
            if tryb == 'Miesiƒôcznie':
                kwota_cancel = 0.0
                desc = f"Odwo≈Çana: {row['Data']} (Brak zwrotu)"
            else:
                # Co zajƒôcia -> Odejmujemy od planu
                day_of_cancel = pd.to_datetime(row['Data']).weekday()
                term_match = None
                for t in terms:
                    if DNI_MAPA.get(t['day_name']) == day_of_cancel:
                        term_match = t
                        break
                
                if term_match:
                    cost_of_lesson = (student_row['Stawka'] * term_match['duration']) + student_row.get('Dojazd', 0)
                    kwota_cancel = -cost_of_lesson
                    desc = f"Odwo≈Çana: {row['Data']} (Odliczenie z planu)"
                else:
                    kwota_cancel = 0.0
                    desc = f"Odwo≈Çana: {row['Data']} (Nieznana stawka)"

            total_amount += kwota_cancel
            breakdown.append({
                "Opis": desc,
                "Kwota": kwota_cancel,
                "Typ": "Korekta"
            })
            
    return total_amount, breakdown

def generate_calendar_events(df_students):
    today = date.today()
    end_date = today + timedelta(days=60)
    start_date = today - timedelta(days=7)
    lessons = get_lessons_in_period(df_students, start_date, end_date)
    events = []
    for l in lessons:
        try:
            godzina_str = str(l['Godzina'])
            if len(godzina_str.split(':')) == 2: godzina_str += ":00"
            start_time = datetime.combine(l['Data'], datetime.strptime(godzina_str, "%H:%M:%S").time())
            duration_hours = l.get('Czas', 1.0)
            end_time = start_time + timedelta(hours=duration_hours)
            
            color = "#3788d8"
            if l['Typ'] == 'Dodatkowa': color = "#28a745"
            elif l['Typ'] == 'Odrabianie': color = "#fd7e14"
            elif l['Typ'] == 'Prze≈Ço≈ºona': color = "#6f42c1"
            
            events.append({
                "title": f"{l['Imie']} {l['Nazwisko']}",
                "start": start_time.isoformat(),
                "end": end_time.isoformat(),
                "backgroundColor": color,
                "borderColor": color,
                "extendedProps": {
                    "Uczen_ID": l['Uczen_ID'],
                    "Typ": l['Typ'],
                    "Data": l['Data'].strftime("%Y-%m-%d"),
                    "Godzina": str(l['Godzina']),
                    "Stawka": l['Stawka'],
                    "Imie": l['Imie'],
                    "Nazwisko": l['Nazwisko'],
                    "Czas": duration_hours
                }
            })
        except: pass
    return events

# --- START APLIKACJI ---
df = load_data()
df_settlements = load_settlements()
df_cancellations = load_cancellations()
df_extra = load_extra()

# AUTOMATYCZNA AKTUALIZACJA LICZNIK√ìW ODRABIANIA (PRZY STARCIE)
if process_past_makeups(df, df_extra):
    # Je≈õli dokonano zmian, prze≈Çadowujemy dane ≈ºeby UI by≈Ço aktualne
    df = load_data()
    df_extra = load_extra()

with st.sidebar:
    st.title("üìö Korepetycje")
    menu = st.radio("Menu", ["üìÖ Kalendarz", "üë§ Szczeg√≥≈Çy Ucznia", "üí∞ Finanse (Wykres)", "‚ûï Dodaj Ucznia", "üìã Baza Danych"])

# --- ZAK≈ÅADKA KALENDARZ ---
if menu == "üìÖ Kalendarz":
    st.header("Grafik Zajƒôƒá")
    
    with st.expander("‚ûï Dodaj dodatkowƒÖ lekcjƒô / odrabianie"):
        student_opts = {f"{r['Imie']} {r['Nazwisko']}": r['ID'] for i, r in df.iterrows()}
        
        c1, c2 = st.columns(2)
        e_name = c1.selectbox("Kto?", list(student_opts.keys()), key="extra_who")
        e_id = student_opts[e_name]
        
        s_row = df[df['ID'] == e_id].iloc[0]
        terms = parse_student_terms(s_row)
        def_dur = terms[0]['duration'] if terms else 1.0
        
        c3, c4 = st.columns(2)
        e_date = c3.date_input("Kiedy?", date.today(), key="extra_date")
        e_time = c4.time_input("O kt√≥rej?", time(17,0), key="extra_time")
        
        c5, c6 = st.columns(2)
        e_dur = c5.number_input("Czas trwania (h)", value=float(def_dur), step=0.25, key="extra_dur")
        
        base_hourly = float(s_row['Stawka'])
        e_hourly = c6.number_input("Stawka (z≈Ç/h)", value=base_hourly, key="extra_hourly")
        
        dojazd_koszt = float(s_row.get('Dojazd', 0))
        final_total = (e_hourly * e_dur) + dojazd_koszt
        
        st.caption(f"‚ÑπÔ∏è Wyliczenie: {e_hourly} z≈Ç/h √ó {e_dur}h + {dojazd_koszt} z≈Ç (dojazd) = **{final_total:.2f} z≈Ç**")
        
        typ_lekcji_ui = st.radio("Typ:", ["Odrabianie", "Dodatkowa"], horizontal=True)
        
        if st.button("Dodaj lekcjƒô"):
            typ_save = "Odrabianie" if typ_lekcji_ui == "Odrabianie" else "Dodatkowa"
            new_extra = pd.DataFrame([{
                'Uczen_ID': e_id, 'Data': e_date, 'Godzina': e_time, 
                'Stawka': final_total, 'Typ': typ_save, 'Czas': e_dur, 'Status': 'Zaplanowana'
            }])
            df_extra = pd.concat([df_extra, new_extra], ignore_index=True)
            save_extra(df_extra)
            
            # AKTUALIZACJA LICZNIK√ìW (GODZINOWO)
            if typ_save == "Odrabianie":
                idx = df.index[df['ID'] == e_id].tolist()
                if idx:
                    idx = idx[0]
                    # Dodajemy tyle godzin ile trwa lekcja
                    df.at[idx, 'Do_odrobienia_umowione'] += e_dur
                    current_pending = df.at[idx, 'Do_odrobienia_nieumowione']
                    if current_pending > 0:
                        df.at[idx, 'Do_odrobienia_nieumowione'] = max(0.0, current_pending - e_dur)
                    save_data(df)
                    st.success(f"Dodano lekcjƒô (Odrabianie {e_dur}h) i zaktualizowano liczniki!")
            else:
                st.success("Dodano lekcjƒô dodatkowƒÖ!")
            st.rerun()

    # --- KALENDARZ ---
    calendar_options = {
        "editable": "true", "locale": "pl", "firstDay": 1,
        "headerToolbar": {"left": "prev,next today", "center": "title", "right": "dayGridMonth,timeGridWeek"},
        "buttonText": {"today": "Dzi≈õ", "month": "MiesiƒÖc", "week": "Tydzie≈Ñ", "day": "Dzie≈Ñ"},
        "slotMinTime": "08:00:00", "slotMaxTime": "22:00:00", "allDaySlot": False,
        "eventTimeFormat": {"hour": "2-digit", "minute": "2-digit", "hour12": False}
    }
    
    events = generate_calendar_events(df)
    cal_state = calendar(events=events, options=calendar_options)
    
    # --- OBS≈ÅUGA KLIKNIƒòCIA ---
    if cal_state.get("eventClick"):
        props = cal_state["eventClick"]["event"]["extendedProps"]
        st.divider()
        st.subheader(f"ZarzƒÖdzanie: {props['Imie']} {props['Nazwisko']} ({props['Data']})")
        col1, col2 = st.columns(2)
        with col1:
            dur_info = props.get('Czas', 1.0)
            st.info(f"Typ: {props['Typ']} | Czas: {dur_info}h | Stawka: {props['Stawka']} z≈Ç")
        with col2:
            st.write("") # Odstƒôp
            if props['Typ'] == 'Sta≈Ça':
                powod_del = st.radio("Kto zawini≈Ç?", ["Wina Ucznia", "Wina Korepetytora"], key="del_reason_click")
                if st.button("‚ùå Odwo≈Çaj zajƒôcia"):
                    nc = pd.DataFrame([{'Uczen_ID': props['Uczen_ID'], 'Data': props['Data'], 'Powod': powod_del}])
                    df_cancellations = pd.concat([df_cancellations, nc], ignore_index=True)
                    save_cancellations(df_cancellations)
                    
                    # Liczniki (GODZINY)
                    idx = df.index[df['ID'] == props['Uczen_ID']].tolist()[0]
                    duration_to_add = float(props.get('Czas', 1.0))
                    
                    if powod_del == "Wina Ucznia":
                        df.at[idx, 'Nieobecnosci'] += 1
                        df.at[idx, 'Odrabiania'] += 1
                        df.at[idx, 'Do_odrobienia_nieumowione'] += duration_to_add
                    else:
                        df.at[idx, 'Do_odrobienia_nieumowione'] += duration_to_add
                    save_data(df)
                    st.success("Odwo≈Çano."); st.rerun()
            else:
                if st.button("üóëÔ∏è Usu≈Ñ z kalendarza"):
                    mask = (df_extra['Uczen_ID'] == props['Uczen_ID']) & (df_extra['Data'] == props['Data']) & (df_extra['Godzina'].astype(str).str.contains(str(props['Godzina'])[:5]))
                    if mask.any():
                        idx = df_extra[mask].index[0]
                        # Je≈õli usuwamy Odrabianie -> cofamy liczniki
                        if props['Typ'] == 'Odrabianie':
                            s_idx = df.index[df['ID'] == props['Uczen_ID']].tolist()
                            if s_idx:
                                s_idx = s_idx[0]
                                dur_to_rev = float(props.get('Czas', 1.0))
                                # Cofamy Umowione (odejmujemy godziny)
                                if df.at[s_idx, 'Do_odrobienia_umowione'] >= dur_to_rev:
                                    df.at[s_idx, 'Do_odrobienia_umowione'] -= dur_to_rev
                                
                                # FIX: Dodajemy z powrotem do puli nieum√≥wionych, skoro to odrabianie zosta≈Ço anulowane
                                df.at[s_idx, 'Do_odrobienia_nieumowione'] += dur_to_rev 
                                
                                save_data(df)
                                st.toast("Cofniƒôto status odrabiania (lekcja wr√≥ci≈Ça do puli nieum√≥wionych).")
                        
                        df_extra = df_extra.drop(idx).reset_index(drop=True)
                        save_extra(df_extra)
                st.success("Usuniƒôto."); st.rerun()

# --- ZAK≈ÅADKA SZCZEG√ì≈ÅY UCZNIA ---
elif menu == "üë§ Szczeg√≥≈Çy Ucznia":
    st.header("Karta Ucznia")
    if df.empty:
        st.warning("Brak uczni√≥w.")
    else:
        student_options = {f"{r['Imie']} {r['Nazwisko']}": r['ID'] for i, r in df.iterrows()}
        selected_student_name = st.selectbox("Wybierz ucznia:", list(student_options.keys()))
        selected_id = student_options[selected_student_name]
        
        student_row = df[df['ID'] == selected_id].iloc[0]
        tryb = student_row.get('Tryb_platnosci', 'Co zajƒôcia')
        terms = parse_student_terms(student_row)
        
        st.markdown("---")
        col_info1, col_info2, col_info3 = st.columns(3)
        with col_info1:
            st.markdown("##### üìû Dane")
            st.write(f"{student_row['Nr_tel']} | {student_row['Szkola']}")
            st.write(f"**Adres:** {student_row['Adres']}")
            st.write(f"**Klasa:** {student_row['Klasa']} | **Poziom:** {student_row['Poziom']}")
        with col_info2:
            st.markdown("##### üìö Warunki")
            dojazd_info = f"+ {student_row.get('Dojazd', 0)} z≈Ç dojazd" if student_row.get('Dojazd', 0) > 0 else ""
            st.write(f"Stawka baza: {student_row['Stawka']} z≈Ç/h {dojazd_info}")
            for t in terms:
                full = (student_row['Stawka'] * t['duration']) + student_row.get('Dojazd', 0)
                st.caption(f"üóìÔ∏è {t['day_name']} {t['time_str']} ({t['duration']}h) ‚û° {full:.2f} z≈Ç")
        
        with col_info3:
            st.markdown("##### üìä Status i Liczniki")
            c_stat1, c_stat2 = st.columns(2)
            c_stat1.metric("Nieobecno≈õci (Sztuki)", int(student_row['Nieobecnosci']))
            c_stat1.metric("Wszystkie Odrabiania", int(student_row['Odrabiania']))
            # Wy≈õwietlamy jako godziny (float)
            c_stat2.metric("Do odrobienia (UM√ìWIONE)", f"{float(student_row['Do_odrobienia_umowione']):.1f}h")
            c_stat2.metric("Do odrobienia (WISZƒÑCE)", f"{float(student_row['Do_odrobienia_nieumowione']):.1f}h", delta_color="inverse")

        # --- PRZYGOTOWANIE DANYCH DO TABELI ---
        start_date = pd.to_datetime(student_row['Data_rozp']).date()
        end_date = pd.to_datetime(student_row['Data_zak']).date()
        effective_end = min(end_date, date.today())
        
        saved_for_student = df_settlements[df_settlements['Uczen_ID'] == selected_id]
        if not saved_for_student.empty: saved_for_student = saved_for_student.set_index('Okres')
        
        table_data = []
        details_map = {}

        # --- LOGIKA MIESIƒòCZNA (Z KOREKTAMI) ---
        if tryb == "Miesiƒôcznie":
            curr = start_date.replace(day=1)
            view_limit = (date.today().replace(day=1) + relativedelta(months=1)) - timedelta(days=1)
            
            df_extra_all = load_extra() # ≈Åadujemy raz, bƒôdziemy filtrowaƒá w pƒôtli
            
            while curr <= view_limit:
                m_str = curr.strftime("%Y-%m")
                # 1. Wiersz Abonamentu
                calc_amount, details = calculate_monthly_breakdown(df, selected_id, curr)
                details_map[m_str] = details
                
                final_req = float(calc_amount)
                paid_val = 0.0
                
                if not saved_for_student.empty and m_str in saved_for_student.index:
                    record = saved_for_student.loc[m_str]
                    if isinstance(record, pd.DataFrame): record = record.iloc[0]
                    paid_val = float(record['Wplacono'])
                
                table_data.append({
                    "ID Okresu": m_str,
                    "Termin": f"{MIESIACE_PL.get(curr.month)} {curr.year}",
                    "Kwota do zap≈Çaty": final_req,
                    "Ile wp≈Çacono": paid_val
                })
                
                # 2. Wiersze lekcji dodatkowych w tym miesiƒÖcu (JAKO OSOBNE POZYCJE)
                month_start = curr
                month_end = curr + relativedelta(months=1) - timedelta(days=1)
                
                extras_in_month = df_extra_all[
                    (df_extra_all['Uczen_ID'] == selected_id) &
                    (df_extra_all['Typ'] == 'Dodatkowa') &
                    (pd.to_datetime(df_extra_all['Data']).dt.date >= month_start) &
                    (pd.to_datetime(df_extra_all['Data']).dt.date <= month_end)
                ]
                
                for _, ex_row in extras_in_month.iterrows():
                    d_str = ex_row['Data'] # YYYY-MM-DD
                    label = f"Lekcja dodatkowa: {d_str}"
                    req = float(ex_row['Stawka'])
                    paid = 0.0
                    
                    if not saved_for_student.empty and d_str in saved_for_student.index:
                        record = saved_for_student.loc[d_str]
                        if isinstance(record, pd.DataFrame): record = record.iloc[0]
                        paid = float(record['Wplacono'])
                    
                    table_data.append({
                        "ID Okresu": d_str,
                        "Termin": label,
                        "Kwota do zap≈Çaty": req,
                        "Ile wp≈Çacono": paid
                    })
                
                curr += relativedelta(months=1)
            
            # Sortujemy malejƒÖco
            table_data.sort(key=lambda x: x['ID Okresu'], reverse=True)

        # --- LOGIKA "CO ZAJƒòCIA" ---
        else:
            all_lessons = get_lessons_in_period(df[df['ID'] == selected_id], start_date, effective_end)
            all_lessons.sort(key=lambda x: x['Data'], reverse=True)
            for l in all_lessons:
                d_str = l['Data'].strftime("%Y-%m-%d")
                label = f"{l['Data'].day} {MIESIACE_PL.get(l['Data'].month)} {l['Data'].year}"
                if l['Typ'] != 'Sta≈Ça': label += f" ({l['Typ']})"
                
                final_req = float(l['Stawka'])
                paid_val = 0.0
                if not saved_for_student.empty and d_str in saved_for_student.index:
                    record = saved_for_student.loc[d_str]
                    if isinstance(record, pd.DataFrame): record = record.iloc[0]
                    paid_val = float(record['Wplacono'])
                    
                table_data.append({
                    "ID Okresu": d_str,
                    "Termin": label,
                    "Kwota do zap≈Çaty": final_req,
                    "Ile wp≈Çacono": paid_val
                })

        # --- SALDO ---
        total_req = sum(r['Kwota do zap≈Çaty'] for r in table_data)
        total_paid = sum(r['Ile wp≈Çacono'] for r in table_data)
        saldo = total_paid - total_req
        
        with col_info3:
            st.markdown("##### üí∞ SALDO")
            color = "green" if saldo >= 0 else "red"
            st.markdown(f"<h2 style='color:{color}'>{saldo:+.2f} z≈Ç</h2>", unsafe_allow_html=True)

        # --- TABELA ---
        st.subheader("üí≥ Rejestr wp≈Çat")
        if not table_data:
            st.info("Brak danych (do dnia dzisiejszego).")
        else:
            df_disp = pd.DataFrame(table_data)
            edited = st.data_editor(
                df_disp,
                column_config={
                    "ID Okresu": None,
                    "Termin": st.column_config.TextColumn(disabled=True),
                    "Kwota do zap≈Çaty": st.column_config.NumberColumn(format="%.2f z≈Ç", disabled=True),
                    "Ile wp≈Çacono": st.column_config.NumberColumn(format="%.2f z≈Ç", min_value=0, step=10)
                },
                hide_index=True, use_container_width=True, key=f"edit_{selected_id}", num_rows="fixed"
            )
            
            if st.button("üíæ Zapisz wp≈Çaty", type="primary"):
                other = df_settlements[df_settlements['Uczen_ID'] != selected_id]
                new_rows = []
                for _, r in edited.iterrows():
                    new_rows.append({
                        'Uczen_ID': selected_id, 
                        'Okres': r['ID Okresu'],
                        'Kwota_Wymagana': r['Kwota do zap≈Çaty'], 
                        'Wplacono': r['Ile wp≈Çacono']
                    })
                updated = pd.concat([other, pd.DataFrame(new_rows)], ignore_index=True)
                save_settlements(updated)
                df_settlements = updated
                st.success("Zapisano!")
                st.rerun()

        # --- SZCZEG√ì≈ÅY MIESIƒòCZNE (WSZYSTKIE, R√ìWNIE≈ª PRZYSZ≈ÅE) ---
        st.divider()
        st.subheader("üîç Szczeg√≥≈Çy wylicze≈Ñ dla miesiƒÖca (Plan)")
        
        # Generujemy pe≈ÇnƒÖ listƒô miesiƒôcy z umowy (r√≥wnie≈º przysz≈Çych)
        month_map = {}
        iter_date = start_date.replace(day=1)
        # Zabezpieczenie: je≈õli end_date jest pusty lub b≈Çƒôdny, bierzemy np. +1 rok
        safe_end = end_date if end_date >= start_date else date.today() + relativedelta(years=1)
        
        while iter_date <= safe_end:
            m_label = f"{MIESIACE_PL.get(iter_date.month)} {iter_date.year}"
            month_map[m_label] = iter_date
            iter_date += relativedelta(months=1)
        
        # Sortujemy malejƒÖco (najnowsze/przysz≈Çe na g√≥rze)
        sorted_opts = sorted(month_map.keys(), key=lambda x: month_map[x], reverse=True)
        
        if sorted_opts:
            sel_month_label = st.selectbox("Wybierz miesiƒÖc do analizy:", sorted_opts)
            target_date = month_map[sel_month_label]
            
            # Liczymy szczeg√≥≈Çy na ≈ºywo dla wybranego miesiƒÖca
            calc_amount, details = calculate_monthly_breakdown(df, selected_id, target_date)
            
            if details:
                det_df = pd.DataFrame(details)
                st.dataframe(det_df, hide_index=True, use_container_width=True)
                # Suma informacyjna
                sum_info = sum(d['Kwota'] for d in details)
                st.caption(f"Suma wyliczona z planu (Abonament + Dodatki): **{sum_info:.2f} z≈Ç**")
            else:
                st.info("Brak pozycji w rachunku.")
        else:
            st.info("Brak miesiƒôcy do wy≈õwietlenia (sprawd≈∫ daty umowy).")

# --- FINANSE ---
elif menu == "üí∞ Finanse (Wykres)":
    st.header("Analiza Finansowa")
    if df.empty: st.info("Brak danych.")
    else:
        today = date.today()
        start_year = date(today.year if today.month >= 9 else today.year - 1, 9, 1)
        end_year = date(today.year + 1 if today.month >= 9 else today.year, 6, 30)
        
        income_total = calculate_income(df, start_year, end_year)
        paid_total = df_settlements['Wplacono'].sum()
        
        c1, c2 = st.columns(2)
        c1.metric("Przych√≥d z Lekcji (Teoria)", f"{income_total} PLN")
        c2.metric("Faktycznie Wp≈Çacono", f"{paid_total} PLN")
        
        monthly_data = []
        curr = start_year
        while curr <= end_year:
            nm = curr + relativedelta(months=1)
            e_m = nm - timedelta(days=1)
            val = calculate_income(df, curr, e_m)
            monthly_data.append({"MiesiƒÖc": f"{MIESIACE_PL.get(curr.month)} {curr.year}", "Przych√≥d": val})
            curr = nm
            
        st.altair_chart(alt.Chart(pd.DataFrame(monthly_data)).mark_bar().encode(
            x=alt.X('MiesiƒÖc', sort=None), y='Przych√≥d', tooltip=['MiesiƒÖc', 'Przych√≥d']
        ), use_container_width=True)

# --- DODAJ UCZNIA ---
elif menu == "‚ûï Dodaj Ucznia":
    st.header("Dodaj nowego ucznia")
    
    # FIX: Checkbox wyciƒÖgniƒôty przed formularz, aby dzia≈Ça≈Ç dynamicznie (od≈õwie≈ºa≈Ç UI po klikniƒôciu)
    use_t2 = st.checkbox("Dodaj Termin 2")
    
    with st.form("add"):
        c1, c2 = st.columns(2)
        imie = c1.text_input("Imiƒô")
        nazwisko = c2.text_input("Nazwisko")
        
        # Sekcja kontaktowa
        c_cont1, c_cont2 = st.columns(2)
        nr_tel = c_cont1.text_input("Numer telefonu")
        adres = c_cont2.text_input("Adres")
        
        # Sekcja szko≈Çy
        c_sch1, c_sch2, c_sch3 = st.columns(3)
        szkola = c_sch1.text_input("Szko≈Ça")
        klasa = c_sch2.text_input("Klasa")
        poziom = c_sch3.selectbox("Poziom", ["Podstawowy", "Rozszerzony", "Inny"])
        
        st.markdown("---")
        
        c3, c4, c5 = st.columns(3)
        data_rozp = c3.date_input("Start", date.today())
        data_zak = c4.date_input("Koniec", date(2026, 6, 26))
        tryb = c5.selectbox("Tryb p≈Çatno≈õci", ["Co zajƒôcia", "Miesiƒôcznie"])
        
        st.markdown("---")
        st.caption("Terminy zajƒôƒá (mo≈ºesz dodaƒá jeden lub wiƒôcej)")
        
        # --- SEKCJA WIELU TERMIN√ìW ---
        col_t1, col_t2, col_t3 = st.columns(3)
        with col_t1:
            st.markdown("**Termin 1 (G≈Ç√≥wny)**")
            d1 = st.selectbox("Dzie≈Ñ 1", list(DNI_MAPA.keys()), key="d1")
            g1 = st.time_input("Godz 1", time(16,0), key="g1")
            len1 = st.number_input("Czas 1 (h)", 1.0, 3.0, 1.0, 0.5, key="l1")
            
        with col_t2:
            st.markdown("**Termin 2**")
            d2 = st.selectbox("Dzie≈Ñ 2", list(DNI_MAPA.keys()), key="d2", disabled=not use_t2)
            g2 = st.time_input("Godz 2", time(16,0), key="g2", disabled=not use_t2)
            len2 = st.number_input("Czas 2 (h)", 1.0, 3.0, 1.0, 0.5, key="l2", disabled=not use_t2)

        c8, c9 = st.columns(2)
        stawka = c8.number_input("Stawka za godzinƒô", value=50)
        dojazd = c9.number_input("Dojazd (z≈Ç) - doliczany do ka≈ºdej lekcji", value=0)
        
        if st.form_submit_button("Zapisz"):
            if not imie or not nazwisko:
                st.error("Imiƒô i Nazwisko sƒÖ wymagane!")
            else:
                # Budowanie string√≥w z wieloma warto≈õciami
                days_str = d1
                times_str = str(g1)
                lens_str = str(len1)
                
                if use_t2:
                    days_str += f";{d2}"
                    times_str += f";{g2}"
                    lens_str += f";{len2}"
                
                new_id = 1 if df.empty else df['ID'].max() + 1
                new_row = {
                    'ID': new_id, 'Imie': imie, 'Nazwisko': nazwisko,
                    'Dzien_tyg': days_str, 'Godzina': times_str,
                    'Data_rozp': data_rozp, 'Data_zak': data_zak, 'Stawka': stawka,
                    'Dojazd': dojazd,
                    'H_w_tygodniu': lens_str, # Teraz przechowuje listƒô czas√≥w trwania
                    'Nieobecnosci': 0, 'Tryb_platnosci': tryb,
                    'Odrabiania': 0, 'Do_odrobienia_umowione': 0, 'Do_odrobienia_nieumowione': 0,
                    'Szkola': szkola, 'Klasa': klasa, 'Poziom': poziom, 'Nr_tel': nr_tel, 'Adres': adres
                }
                for col in COLUMNS: 
                    if col not in new_row: new_row[col] = ""
                df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)
                save_data(df)
                st.success("Dodano!")
                st.rerun()

# --- BAZA DANYCH ---
elif menu == "üìã Baza Danych":
    st.header("PodglƒÖd i edycja plik√≥w CSV")
    edited = st.data_editor(df, num_rows="dynamic", key="edit_db_students")
    if st.button("Zapisz Uczni√≥w"): save_data(edited); st.success("Zapisano!")
    
    st.divider()
    c1, c2 = st.columns(2)
    with c1:
        st.caption("Odwo≈Çane")
        if not df_cancellations.empty:
            if st.button("Zapisz Odwo≈Çane"): save_cancellations(st.data_editor(df_cancellations, num_rows="dynamic"))
    with c2:
        st.caption("Dodatkowe")
        if not df_extra.empty:
            if st.button("Zapisz Dodatkowe"): save_extra(st.data_editor(df_extra, num_rows="dynamic"))